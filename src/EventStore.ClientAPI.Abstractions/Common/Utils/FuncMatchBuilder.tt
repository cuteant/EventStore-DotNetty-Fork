<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
using System;
using System.Linq.Expressions;
using System.Reflection;

<# var count = 10; #>
#if CLIENTAPI
namespace EventStore.ClientAPI.Common.Utils
#else
namespace EventStore.Common.Utils
#endif
{
<# for (int i = 1; i <= count; i++) {
    var types = string.Join(", ", Enumerable.Range(1, i).Select(x => "TArg" + x));
    var arguments = string.Join(", ", Enumerable.Range(1, i).Select(x => "arg" + x));
    var typeAndArguments = string.Join(", ", Enumerable.Range(1, i).Select(x => "TArg" + x + " arg" + x));
    var gParameters = string.Join(", ", Enumerable.Range(1, i).Select(x => "Parameter" + x));
#>
    /// <summary>Pattern matcher</summary>
    /// <typeparam name="TIn">Argument type</typeparam>
<# for (var t = 1; t <= i; t++) { #>
    /// <typeparam name="TArg<#= t #>">Argument type</typeparam>
<# } #>
    /// <typeparam name="TOut">Return type</typeparam>
    public sealed class FuncMatchBuilder<TIn, <#= types #>, TOut> : FuncMatchBuilderBase<Func<TIn, <#= types #>, TOut>, TIn, TOut>
    {
<# for (var t = 1; t <= i; t++) { #>
        private ParameterExpression _parameter<#= t #>;
        /// <summary>Expression representing matching parameter</summary>
        private ParameterExpression Parameter<#= t #> => _parameter<#= t #> ?? (_parameter<#= t #> = Expression.Parameter(typeof(TArg<#= t #>), "arg<#= t #>"));
<# } #>

        private ParameterExpression[] _parameters;
        protected override ParameterExpression[] Parameters => _parameters ?? (_parameters = new[] 
            { 
                Parameter, <#= gParameters #>
            });

        /// <summary>Adds context-based matching case</summary>
        /// <typeparam name="TCtx">Context type</typeparam>
        public void Match<TCtx>(Func<TCtx, <#= types #>, TOut> handler) where TCtx : TIn
        {
            Match<TCtx>(processor: (_, <#= arguments #>) => handler(_, <#= arguments #>));
        }

        /// <summary>Adds context-based matching case</summary>
        /// <typeparam name="TCtx">Context type</typeparam>
        public void Match<TCtx>(Expression<Func<TCtx, <#= types #>, TOut>> processor) where TCtx : TIn
        {
            EnsureCanAdd();
            var ctxType = typeof(TCtx);
            var bindResult = Expression.Variable(typeof(TCtx), "binded");
            BlockExpression caseExpr;
            if (ctxType.GetTypeInfo().IsValueType)
            {
                caseExpr = Expression.Block(
                    Expression.IfThen(
                        Expression.TypeIs(Parameter, ctxType),
                        Expression.Block(
                            new[] { bindResult },
                            Expression.Assign(bindResult, Expression.Convert(Parameter, ctxType)),
                            Expression.Return(RetPoint, Expression.Invoke(processor, bindResult, <#= gParameters #>))
                        )
                    )
                );
            }
            else
            {
                caseExpr = Expression.Block(
                new[] { bindResult },
                Expression.Assign(bindResult, Expression.TypeAs(Parameter, ctxType)),
                Expression.IfThen(
                    Expression.NotEqual(bindResult, Expression.Constant(null)),
                    Expression.Return(RetPoint, Expression.Invoke(processor, bindResult, <#= gParameters #>))
                ));
            }
            CaseExpressionsList.Add(caseExpr);
            if (ctxType == ItemType) { _state = State.MatchAnyAdded; }
        }

        /// <summary>Adds context-based matching case</summary>
        /// <typeparam name="TCtx">Context type</typeparam>
        public void Match<TCtx>(Func<TCtx, <#= types #>, TOut> handler, Predicate<TCtx> shouldHandle) where TCtx : TIn
        {
            Match<TCtx>(processor: (_, <#= arguments #>) => handler(_, <#= arguments #>), condition: _ => shouldHandle(_));
        }

        /// <summary>Adds context-based matching case</summary>
        /// <typeparam name="TCtx">Context type</typeparam>
        public void Match<TCtx>(Expression<Func<TCtx, <#= types #>, TOut>> processor, Expression<Predicate<TCtx>> condition) where TCtx : TIn
        {
            EnsureCanAdd();
            var ctxType = typeof(TCtx);
            var bindResult = Expression.Variable(ctxType, "binded");
            BlockExpression caseExpr;
            if (ctxType.GetTypeInfo().IsValueType)
            {
                caseExpr = Expression.Block(
                    Expression.IfThen(
                        Expression.TypeIs(Parameter, ctxType),
                        Expression.Block(
                            new[] { bindResult },
                            Expression.Assign(bindResult, Expression.Convert(Parameter, ctxType)),
                            Expression.IfThen(
                                Expression.Invoke(condition, bindResult),
                                Expression.Return(RetPoint, Expression.Invoke(processor, bindResult, <#= gParameters #>))
                            )
                        )
                    )
                );
            }
            else
            {
                caseExpr = Expression.Block(
                    new[] { bindResult },
                    Expression.Assign(bindResult, Expression.TypeAs(Parameter, ctxType)),
                    Expression.IfThen(
                        Expression.AndAlso(
                            Expression.NotEqual(bindResult, Expression.Constant(null)),
                            Expression.Invoke(condition, bindResult)
                            ),
                        Expression.Return(RetPoint, Expression.Invoke(processor, bindResult, <#= gParameters #>))
                    )
                );
            }
            CaseExpressionsList.Add(caseExpr);
        }

        /// <summary>Adds predicated-based matching case</summary>
        public void Match(Predicate<TIn> shouldHandle, Func<TIn, <#= types #>, TOut> handler)
        {
            Match(condition: _ => shouldHandle(_), processor: (_, <#= arguments #>) => handler(_, <#= arguments #>));
        }

        public void MatchAny(Func<TIn, <#= types #>, TOut> handler)
        {
            EnsureCanAdd();
            FinalExpr = CreatePredicatedBasedExpr(condition: _ => true, processor: (_, <#= arguments #>) => handler(_, <#= arguments #>));
            _state = State.MatchAnyAdded;
        }

        public bool TryMatchAny(Func<TIn, <#= types #>, TOut> handler)
        {
            if (FinalExpr != null) { return false; }
            FinalExpr = CreatePredicatedBasedExpr(condition: _ => true, processor: (_, <#= arguments #>) => handler(_, <#= arguments #>));
            _state = State.MatchAnyAdded;
            return true;
        }

        /// <summary>Performs match on the given value</summary>
        public TOut Match(TIn value, <#= typeAndArguments #>) => MatcherFunc(value, <#= arguments #>);

        /// <summary>Converts matcher into Func&lt;T&gt; instance</summary>
        public static implicit operator Func<TIn, <#= types #>, TOut>(FuncMatchBuilder<TIn, <#= types #>, TOut> matcher) => matcher.MatcherFunc;
    }
<# } #>
}